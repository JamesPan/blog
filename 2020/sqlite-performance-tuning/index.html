<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>SQLite performance tuning - Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second - phiresky&#x27;s blog</title><meta name="description" content="SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="alternate" type="application/rss+xml" title="RSS feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/rss.xml"/><link rel="alternate" type="application/atom+xml" title="Atom feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/atom.xml"/><link rel="alternate" type="application/json" title="JSON feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/feed.json"/><style>
          body {
            font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
          }
      </style><meta name="next-head-count" content="8"/><link rel="preload" href="/blog/_next/static/css/3acfbf97185f61973398.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/3acfbf97185f61973398.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/52d8d008d21e161451c9.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/52d8d008d21e161451c9.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/5010e8538e0af805e524.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/5010e8538e0af805e524.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/webpack-63a283d2f74069c6a8dd.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework-1e76997b852ac269fbe9.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons-d9b220e8b050827068fb.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/main-00e068cce0587a1a04cb.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-88dabe7ea4fbfcfa845c.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/247-98ffd97863a3e7b70e09.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/878-98e4c7d60a75cb0a9a7d.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/%5Byear%5D/%5Bpost%5D-8b004dc8d3effe02d586.js" as="script"/></head><body><div id="__next"><div><div><main class="lh-copy"><div class="relative tc bg-dark-gray"><div class="mw7 center white"><div class="pv4"><h1 class="f2 normal lh-title ma0 pa0"><a class="white no-underline" href="/blog/">phiresky&#x27;s blog</a></h1><h4 class="normal o-70 ma0 pt2 pb3 ph1">About my personal projects and other stuff</h4><div><a href="https://phiresky.github.io/blog/" class="dib f6 white no-underline pa1 ma1">Blog</a><a href="https://github.com/phiresky/" class="dib f6 white no-underline pa1 ma1">GitHub</a></div></div></div></div><div class="content center mw7 pa3 pa4-ns"><h1 class="mt0 lh-title mb1">SQLite performance tuning</h1><p class="mt0">Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second</p><small class="db ttu o-40"><time dateTime="2020-06-26T00:00:00.000Z">Jun 26, 2020</time></small><p>SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only two files you can easily copy or move around. You can still connect to and query the same database concurrently with multiple processes, though only one write operation can happen at the same time.</p><p>SQLite is often seen as a toy database only suitable for databases with a few hundred entries and without any performance requirements, but you can scale a SQLite database to multiple GByte in size and many concurrent readers while maintaining high performance by applying the below optimizations.</p><h2 id="run-these-every-time-you-connect-to-the-db" attrs="[object Object]">Run these every time you connect to the DB</h2><p>Some of these are applied permanently, but others are reset on new connection, so it’s recommended to run all of these each time you connect to the database.</p><ul><li><p>Journal Mode</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma journal_mode </span><span class="token token" style="color:#67cdcc">=</span><span> WAL</span><span class="token token" style="color:#ccc">;</span></code></pre><p>Instead of writing changes directly to the db file, write to a write-ahead-log instead and regularily commit the changes. This allows multiple concurrent readers, and can significantly improve performance.</p></li><li><p>Synchronous Commit</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma synchronous </span><span class="token token" style="color:#67cdcc">=</span><span> normal</span><span class="token token" style="color:#ccc">;</span></code></pre><p>or even <code attrs="[object Object]">synchronous=off</code>. The default is <code attrs="[object Object]">full</code>, which means every single update has to wait for <a href="https://en.wikipedia.org/wiki/Sync_(Unix)" attrs="[object Object]">FSYNC</a>. Normal is still completely corruption safe in WAL mode, and means only WAL checkpoints have to wait for FSYNC. Off can cause db corruption, though I’ve never had problems. See here: <a href="https://www.sqlite.org/pragma.html#pragma_synchronous" class="auto-linked" attrs="[object Object]">https://www.sqlite.org/pragma.html#pragma_synchronous</a></p></li><li><p>Temporary files location</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma temp_store </span><span class="token token" style="color:#67cdcc">=</span><span> memory</span><span class="token token" style="color:#ccc">;</span></code></pre><p>Stores temporary indices / tables in memory. sqlite automatically <a href="https://www.sqlite.org/tempfiles.html#transient_indices" attrs="[object Object]">creates temporary indices</a> for some queries. Not sure how much this one helps.</p></li><li><p>Enable memory mapping</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma mmap_size </span><span class="token token" style="color:#67cdcc">=</span><span> </span><span class="token token" style="color:#f08d49">30000000000</span><span class="token token" style="color:#ccc">;</span></code></pre><p>Uses memory mapping instead of read/write calls when db is &lt; mmap_size. Less syscalls, and pages and caches will be managed by the OS, so the performance of this depends on your operating system. Note that it will not use this amount of physical memory, just virtual memory. Should be much faster on at least Linux.</p></li><li><p>Increase the page size</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma page_size </span><span class="token token" style="color:#67cdcc">=</span><span> </span><span class="token token" style="color:#f08d49">32768</span><span class="token token" style="color:#ccc">;</span></code></pre><p>This improved performance and db size a lot for me in one project, but it’s probably only useful if you are storing somewhat large blobs in your database and might not be good for other projects where rows are small.</p></li></ul><h3 id="summary" attrs="[object Object]">Summary</h3><p>If you’re too lazy to read all the above, just run this on every database connect:</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma journal_mode </span><span class="token token" style="color:#67cdcc">=</span><span> WAL</span><span class="token token" style="color:#ccc">;</span><span>
</span><span>pragma synchronous </span><span class="token token" style="color:#67cdcc">=</span><span> normal</span><span class="token token" style="color:#ccc">;</span><span>
</span><span>pragma temp_store </span><span class="token token" style="color:#67cdcc">=</span><span> memory</span><span class="token token" style="color:#ccc">;</span><span>
</span><span>pragma mmap_size </span><span class="token token" style="color:#67cdcc">=</span><span> </span><span class="token token" style="color:#f08d49">30000000000</span><span class="token token" style="color:#ccc">;</span></code></pre><h2 id="more-things-that-must-be-run-manually" attrs="[object Object]">More things that must be run manually</h2><ul><li><p>Reorganize the database</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma vacuum</span><span class="token token" style="color:#ccc">;</span></code></pre><p>Run once to completely rewrite the db. Very expensive if your database is 100MB+.</p></li><li><p>Re-analyze the database</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma </span><span class="token token" style="color:#cc99cd">optimize</span><span class="token token" style="color:#ccc">;</span></code></pre><blockquote><p>To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run <span class="quoted">&quot;<!-- -->PRAGMA optimize<!-- -->&quot;</span> (with no arguments) just before closing each database connection. Long-running applications might also benefit from setting a timer to run <span class="quoted">&quot;<!-- -->PRAGMA optimize<!-- -->&quot;</span> every few hours. <span class="source" attrs="[object Object]"><a href="https://www.sqlite.org/pragma.html#pragma_optimize" class="uri" attrs="[object Object]">https://www.sqlite.org/pragma.html#pragma_optimize</a></span></p></blockquote></li><li><p>Vacuum the database</p><pre class="sql" style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-sql" style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>pragma auto_vacuum </span><span class="token token" style="color:#67cdcc">=</span><span> incremental</span><span class="token token" style="color:#ccc">;</span><span> </span><span class="token token" style="color:#999">-- once on first DB create</span><span>
</span><span>pragma incremental_vacuum</span><span class="token token" style="color:#ccc">;</span><span> </span><span class="token token" style="color:#999">-- regularily</span></code></pre><p>Probably not useful unless you expect your DB to shrink significantly regularily.</p><blockquote><p>The freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages […]. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the VACUUM command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse. <span class="source" attrs="[object Object]"><a href="https://www.sqlite.org/pragma.html#pragma_incremental_vacuum" class="uri" attrs="[object Object]">https://www.sqlite.org/pragma.html#pragma_incremental_vacuum</a></span></p></blockquote></li></ul><h2 id="regarding-wal-mode" attrs="[object Object]">Regarding WAL mode</h2><p>WAL mode has some issues where depending on the write pattern, the WAL size can grow to infinity, slowing down performance a lot. I think this usually happens when you have lots of writes that lock the table so sqlite never gets to <a href="https://www.sqlite.org/wal.html#ckpt" attrs="[object Object]">doing wal_autocheckpoint</a>. There’s a few ways to mitigate this:</p><ol start="1" type="1"><li>Reduce <a href="https://www.sqlite.org/pragma.html#pragma_wal_autocheckpoint" attrs="[object Object]">wal_autocheckpoint interval</a>. No guarantees since all autocheckpoints are passive.</li><li>Run <code attrs="[object Object]">pragma wal_checkpoint(full)</code> or <code attrs="[object Object]">pragma wal_checkpoint(truncate)</code> sometimes. With <code attrs="[object Object]">full</code>, the WAL file won’t change size if other processes have the file open but still commit everything so new data will not cause the WAL file to grow. If you run <code attrs="[object Object]">truncate</code> it will block other processes and reset the WAL file to zero bytes. Note that you <em>can</em> run these from a separate process.</li></ol></div><footer class="center w5 f6 tc mt4"><p><a href="https://github.com/phiresky/blog/blob/master/posts/2020/sqlite-performance-tuning.md">View post source on GitHub</a></p></footer><div><script>/* yes, I know... fite me */
  (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
  function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
  e=o.createElement(i);r=o.getElementsByTagName(i)[0];
  e.src='https://www.google-analytics.com/analytics.js';
  r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
  ga('create','UA-39197996-3','auto');ga('send','pageview');
</script></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"filename":"2020/sqlite-performance-tuning.md","frontmatter":{"csl":"../ieee-with-url.csl","date":"2020-06-26","hidden":false,"references":[],"subtitle":"Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second","title":"SQLite performance tuning","url2cite-link-output":"sup"},"preview":"SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only","content_ast":[{"t":"Para","c":[{"t":"Str","c":"SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only two files you can easily copy or move around. You can still connect to and query the same database concurrently with multiple processes, though only one write operation can happen at the same time."}]},{"t":"Para","c":[{"t":"Str","c":"SQLite is often seen as a toy database only suitable for databases with a few hundred entries and without any performance requirements, but you can scale a SQLite database to multiple GByte in size and many concurrent readers while maintaining high performance by applying the below optimizations."}]},{"t":"Header","c":[2,["run-these-every-time-you-connect-to-the-db",[],[]],[{"t":"Str","c":"Run these every time you connect to the DB"}]]},{"t":"Para","c":[{"t":"Str","c":"Some of these are applied permanently, but others are reset on new connection, so it’s recommended to run all of these each time you connect to the database."}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Str","c":"Journal Mode"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma journal_mode = WAL;"]},{"t":"Para","c":[{"t":"Str","c":"Instead of writing changes directly to the db file, write to a write-ahead-log instead and regularily commit the changes. This allows multiple concurrent readers, and can significantly improve performance."}]}],[{"t":"Para","c":[{"t":"Str","c":"Synchronous Commit"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma synchronous = normal;"]},{"t":"Para","c":[{"t":"Str","c":"or even "},{"t":"Code","c":[["",[],[]],"synchronous=off"]},{"t":"Str","c":". The default is "},{"t":"Code","c":[["",[],[]],"full"]},{"t":"Str","c":", which means every single update has to wait for "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"FSYNC"}],["https://en.wikipedia.org/wiki/Sync_(Unix)",""]]},{"t":"Str","c":". Normal is still completely corruption safe in WAL mode, and means only WAL checkpoints have to wait for FSYNC. Off can cause db corruption, though I’ve never had problems. See here: "},{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_synchronous"}],["https://www.sqlite.org/pragma.html#pragma_synchronous",""]]}]}],[{"t":"Para","c":[{"t":"Str","c":"Temporary files location"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma temp_store = memory;"]},{"t":"Para","c":[{"t":"Str","c":"Stores temporary indices / tables in memory. sqlite automatically "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"creates temporary indices"}],["https://www.sqlite.org/tempfiles.html#transient_indices",""]]},{"t":"Str","c":" for some queries. Not sure how much this one helps."}]}],[{"t":"Para","c":[{"t":"Str","c":"Enable memory mapping"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma mmap_size = 30000000000;"]},{"t":"Para","c":[{"t":"Str","c":"Uses memory mapping instead of read/write calls when db is \u003c mmap_size. Less syscalls, and pages and caches will be managed by the OS, so the performance of this depends on your operating system. Note that it will not use this amount of physical memory, just virtual memory. Should be much faster on at least Linux."}]}],[{"t":"Para","c":[{"t":"Str","c":"Increase the page size"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma page_size = 32768;"]},{"t":"Para","c":[{"t":"Str","c":"This improved performance and db size a lot for me in one project, but it’s probably only useful if you are storing somewhat large blobs in your database and might not be good for other projects where rows are small."}]}]]},{"t":"Header","c":[3,["summary",[],[]],[{"t":"Str","c":"Summary"}]]},{"t":"Para","c":[{"t":"Str","c":"If you’re too lazy to read all the above, just run this on every database connect:"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma journal_mode = WAL;\npragma synchronous = normal;\npragma temp_store = memory;\npragma mmap_size = 30000000000;"]},{"t":"Header","c":[2,["more-things-that-must-be-run-manually",[],[]],[{"t":"Str","c":"More things that must be run manually"}]]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Str","c":"Reorganize the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma vacuum;"]},{"t":"Para","c":[{"t":"Str","c":"Run once to completely rewrite the db. Very expensive if your database is 100MB+."}]}],[{"t":"Para","c":[{"t":"Str","c":"Re-analyze the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma optimize;"]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" (with no arguments) just before closing each database connection. Long-running applications might also benefit from setting a timer to run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" every few hours. "},{"t":"Span","c":[["",["source"],[]],[{"t":"Link","c":[["",["uri"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_optimize"}],["https://www.sqlite.org/pragma.html#pragma_optimize",""]]}]]}]}]}],[{"t":"Para","c":[{"t":"Str","c":"Vacuum the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma auto_vacuum = incremental; -- once on first DB create\npragma incremental_vacuum; -- regularily"]},{"t":"Para","c":[{"t":"Str","c":"Probably not useful unless you expect your DB to shrink significantly regularily."}]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"The freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages […]. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the VACUUM command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse. "},{"t":"Span","c":[["",["source"],[]],[{"t":"Link","c":[["",["uri"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_incremental_vacuum"}],["https://www.sqlite.org/pragma.html#pragma_incremental_vacuum",""]]}]]}]}]}]]},{"t":"Header","c":[2,["regarding-wal-mode",[],[]],[{"t":"Str","c":"Regarding WAL mode"}]]},{"t":"Para","c":[{"t":"Str","c":"WAL mode has some issues where depending on the write pattern, the WAL size can grow to infinity, slowing down performance a lot. I think this usually happens when you have lots of writes that lock the table so sqlite never gets to "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"doing wal_autocheckpoint"}],["https://www.sqlite.org/wal.html#ckpt",""]]},{"t":"Str","c":". There’s a few ways to mitigate this:"}]},{"t":"OrderedList","c":[[1,{"t":"Decimal"},{"t":"Period"}],[[{"t":"Plain","c":[{"t":"Str","c":"Reduce "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"wal_autocheckpoint interval"}],["https://www.sqlite.org/pragma.html#pragma_wal_autocheckpoint",""]]},{"t":"Str","c":". No guarantees since all autocheckpoints are passive."}]}],[{"t":"Plain","c":[{"t":"Str","c":"Run "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(full)"]},{"t":"Str","c":" or "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(truncate)"]},{"t":"Str","c":" sometimes. With "},{"t":"Code","c":[["",[],[]],"full"]},{"t":"Str","c":", the WAL file won’t change size if other processes have the file open but still commit everything so new data will not cause the WAL file to grow. If you run "},{"t":"Code","c":[["",[],[]],"truncate"]},{"t":"Str","c":" it will block other processes and reset the WAL file to zero bytes. Note that you "},{"t":"Emph","c":[{"t":"Str","c":"can"}]},{"t":"Str","c":" run these from a separate process."}]}]]]}],"default":{"filename":"2020/sqlite-performance-tuning.md","frontmatter":{"csl":"../ieee-with-url.csl","date":"2020-06-26","hidden":false,"references":[],"subtitle":"Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second","title":"SQLite performance tuning","url2cite-link-output":"sup"},"preview":"SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only","content_ast":[{"t":"Para","c":[{"t":"Str","c":"SQLite is an embedded SQL database. It’s extremely easy to setup, buildable as a single C file with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only two files you can easily copy or move around. You can still connect to and query the same database concurrently with multiple processes, though only one write operation can happen at the same time."}]},{"t":"Para","c":[{"t":"Str","c":"SQLite is often seen as a toy database only suitable for databases with a few hundred entries and without any performance requirements, but you can scale a SQLite database to multiple GByte in size and many concurrent readers while maintaining high performance by applying the below optimizations."}]},{"t":"Header","c":[2,["run-these-every-time-you-connect-to-the-db",[],[]],[{"t":"Str","c":"Run these every time you connect to the DB"}]]},{"t":"Para","c":[{"t":"Str","c":"Some of these are applied permanently, but others are reset on new connection, so it’s recommended to run all of these each time you connect to the database."}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Str","c":"Journal Mode"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma journal_mode = WAL;"]},{"t":"Para","c":[{"t":"Str","c":"Instead of writing changes directly to the db file, write to a write-ahead-log instead and regularily commit the changes. This allows multiple concurrent readers, and can significantly improve performance."}]}],[{"t":"Para","c":[{"t":"Str","c":"Synchronous Commit"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma synchronous = normal;"]},{"t":"Para","c":[{"t":"Str","c":"or even "},{"t":"Code","c":[["",[],[]],"synchronous=off"]},{"t":"Str","c":". The default is "},{"t":"Code","c":[["",[],[]],"full"]},{"t":"Str","c":", which means every single update has to wait for "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"FSYNC"}],["https://en.wikipedia.org/wiki/Sync_(Unix)",""]]},{"t":"Str","c":". Normal is still completely corruption safe in WAL mode, and means only WAL checkpoints have to wait for FSYNC. Off can cause db corruption, though I’ve never had problems. See here: "},{"t":"Link","c":[["",["auto-linked"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_synchronous"}],["https://www.sqlite.org/pragma.html#pragma_synchronous",""]]}]}],[{"t":"Para","c":[{"t":"Str","c":"Temporary files location"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma temp_store = memory;"]},{"t":"Para","c":[{"t":"Str","c":"Stores temporary indices / tables in memory. sqlite automatically "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"creates temporary indices"}],["https://www.sqlite.org/tempfiles.html#transient_indices",""]]},{"t":"Str","c":" for some queries. Not sure how much this one helps."}]}],[{"t":"Para","c":[{"t":"Str","c":"Enable memory mapping"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma mmap_size = 30000000000;"]},{"t":"Para","c":[{"t":"Str","c":"Uses memory mapping instead of read/write calls when db is \u003c mmap_size. Less syscalls, and pages and caches will be managed by the OS, so the performance of this depends on your operating system. Note that it will not use this amount of physical memory, just virtual memory. Should be much faster on at least Linux."}]}],[{"t":"Para","c":[{"t":"Str","c":"Increase the page size"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma page_size = 32768;"]},{"t":"Para","c":[{"t":"Str","c":"This improved performance and db size a lot for me in one project, but it’s probably only useful if you are storing somewhat large blobs in your database and might not be good for other projects where rows are small."}]}]]},{"t":"Header","c":[3,["summary",[],[]],[{"t":"Str","c":"Summary"}]]},{"t":"Para","c":[{"t":"Str","c":"If you’re too lazy to read all the above, just run this on every database connect:"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma journal_mode = WAL;\npragma synchronous = normal;\npragma temp_store = memory;\npragma mmap_size = 30000000000;"]},{"t":"Header","c":[2,["more-things-that-must-be-run-manually",[],[]],[{"t":"Str","c":"More things that must be run manually"}]]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Str","c":"Reorganize the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma vacuum;"]},{"t":"Para","c":[{"t":"Str","c":"Run once to completely rewrite the db. Very expensive if your database is 100MB+."}]}],[{"t":"Para","c":[{"t":"Str","c":"Re-analyze the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma optimize;"]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" (with no arguments) just before closing each database connection. Long-running applications might also benefit from setting a timer to run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" every few hours. "},{"t":"Span","c":[["",["source"],[]],[{"t":"Link","c":[["",["uri"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_optimize"}],["https://www.sqlite.org/pragma.html#pragma_optimize",""]]}]]}]}]}],[{"t":"Para","c":[{"t":"Str","c":"Vacuum the database"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma auto_vacuum = incremental; -- once on first DB create\npragma incremental_vacuum; -- regularily"]},{"t":"Para","c":[{"t":"Str","c":"Probably not useful unless you expect your DB to shrink significantly regularily."}]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"The freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages […]. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the VACUUM command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse. "},{"t":"Span","c":[["",["source"],[]],[{"t":"Link","c":[["",["uri"],[]],[{"t":"Str","c":"https://www.sqlite.org/pragma.html#pragma_incremental_vacuum"}],["https://www.sqlite.org/pragma.html#pragma_incremental_vacuum",""]]}]]}]}]}]]},{"t":"Header","c":[2,["regarding-wal-mode",[],[]],[{"t":"Str","c":"Regarding WAL mode"}]]},{"t":"Para","c":[{"t":"Str","c":"WAL mode has some issues where depending on the write pattern, the WAL size can grow to infinity, slowing down performance a lot. I think this usually happens when you have lots of writes that lock the table so sqlite never gets to "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"doing wal_autocheckpoint"}],["https://www.sqlite.org/wal.html#ckpt",""]]},{"t":"Str","c":". There’s a few ways to mitigate this:"}]},{"t":"OrderedList","c":[[1,{"t":"Decimal"},{"t":"Period"}],[[{"t":"Plain","c":[{"t":"Str","c":"Reduce "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"wal_autocheckpoint interval"}],["https://www.sqlite.org/pragma.html#pragma_wal_autocheckpoint",""]]},{"t":"Str","c":". No guarantees since all autocheckpoints are passive."}]}],[{"t":"Plain","c":[{"t":"Str","c":"Run "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(full)"]},{"t":"Str","c":" or "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(truncate)"]},{"t":"Str","c":" sometimes. With "},{"t":"Code","c":[["",[],[]],"full"]},{"t":"Str","c":", the WAL file won’t change size if other processes have the file open but still commit everything so new data will not cause the WAL file to grow. If you run "},{"t":"Code","c":[["",[],[]],"truncate"]},{"t":"Str","c":" it will block other processes and reset the WAL file to zero bytes. Note that you "},{"t":"Emph","c":[{"t":"Str","c":"can"}]},{"t":"Str","c":" run these from a separate process."}]}]]]}]}}},"__N_SSG":true},"page":"/[year]/[post]","query":{"year":"2020","post":"sqlite-performance-tuning"},"buildId":"AEBJ__D93-qKOtaOBPPiQ","assetPrefix":"/blog","isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-7f99f00b02c1734b8752.js"></script><script src="/blog/_next/static/chunks/webpack-63a283d2f74069c6a8dd.js" async=""></script><script src="/blog/_next/static/chunks/framework-1e76997b852ac269fbe9.js" async=""></script><script src="/blog/_next/static/chunks/commons-d9b220e8b050827068fb.js" async=""></script><script src="/blog/_next/static/chunks/main-00e068cce0587a1a04cb.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-88dabe7ea4fbfcfa845c.js" async=""></script><script src="/blog/_next/static/chunks/247-98ffd97863a3e7b70e09.js" async=""></script><script src="/blog/_next/static/chunks/878-98e4c7d60a75cb0a9a7d.js" async=""></script><script src="/blog/_next/static/chunks/pages/%5Byear%5D/%5Bpost%5D-8b004dc8d3effe02d586.js" async=""></script><script src="/blog/_next/static/AEBJ__D93-qKOtaOBPPiQ/_buildManifest.js" async=""></script><script src="/blog/_next/static/AEBJ__D93-qKOtaOBPPiQ/_ssgManifest.js" async=""></script></body></html>