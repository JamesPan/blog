<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>SQlite performance tuning - Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second - phiresky&#x27;s blog</title><meta name="description" content="SQLite is an embedded SQL database that mimics the PostgreSQL query syntax. It’s extremely easy to setup, with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="alternate" type="application/rss+xml" title="RSS feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/rss.xml"/><link rel="alternate" type="application/atom+xml" title="Atom feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/atom.xml"/><link rel="alternate" type="application/json" title="JSON feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/feed.json"/><style>
          body {
            font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
          }
      </style><meta name="next-head-count" content="8"/><link rel="preload" href="/blog/_next/static/css/styles.d0c8ab1a.chunk.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/styles.d0c8ab1a.chunk.css"/><link rel="preload" href="/blog/_next/static/w6yMeJS-Ar_5gYMMOCrtm/pages/_app.js" as="script"/><link rel="preload" href="/blog/_next/static/w6yMeJS-Ar_5gYMMOCrtm/pages/post.js" as="script"/><link rel="preload" href="/blog/_next/static/runtime/webpack-51670fedc58181f2a5ba.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework.863892844f7f82998c77.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons.e37083b02f3da808fc65.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/styles.0bf15041ddf6570a62b9.js" as="script"/><link rel="preload" href="/blog/_next/static/runtime/main-d9959e011352fa92f435.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/a1bc03cf.11076168cfbd5b32b98d.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/06447f4e.4bc253d795120c94810e.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/c78d26b1.64425fbfab6f2d75c31a.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/15220c3dd78d48351fd3e78a3f003361180e4b66.ec41676bcf086898de3d.js" as="script"/><style id="__jsx-2809278127">.content a{color:#0365a5;-webkit-text-decoration:none;text-decoration:none;border-bottom:1px solid #dfdfdf;-webkit-transition:all 300ms ease;transition:all 300ms ease;}a:hover,a:focus{border-bottom-color:currentColor;}code{background-color:#eee;line-height:1;border-radius:2px;padding:1px;}code{border:1px solid #ddd;}pre code{border:none;}pre{white-space:pre-wrap;word-wrap:break-word;}</style></head><body><div id="__next"><div class="jsx-2809278127"><div><main class="lh-copy"><div class="relative tc bg-dark-gray"><div class="mw7 center white"><div class="pv4"><h4 class="normal o-70 ma0 pt2 pb3 ph1">About my personal projects and other stuff</h4><div><a href="https://phiresky.github.io/blog/" class="dib f6 white no-underline pa1 ma1">Blog</a><a href="https://github.com/phiresky/" class="dib f6 white no-underline pa1 ma1">GitHub</a></div></div></div></div><div class="jsx-2809278127 content center mw7 pa3 pa4-ns"><h1 class="jsx-2809278127 mt0 lh-title">SQlite performance tuning - Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second</h1><small class="db ttu o-40"><time dateTime="2020-06-26T00:00:00.000Z">Jun 26, 2020</time></small><p>SQLite is an embedded SQL database that mimics the PostgreSQL query syntax. It’s extremely easy to setup, with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only two files you can easily copy or move around. You can still connect to and query the same database concurrently with multiple processes, though only one write operation can happen at the same time.</p><p>SQLite is often seen as only a toy database only suitable for databases with a few hundred entries and without any performance requirements, but you can scale a SQLite database to multiple GByte in size and many concurrent readers while maintaining high performance by applying the below optimizations.</p><h2 id="run-these-every-time-you-connect-to-the-db">Run these every time you connect to the db</h2><p>Some of these are applied permanently, but others are reset on new connection, so it’s recommended to run all of these each time you connect to the database.</p><pre style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">pragma journal_mode <span class="token" style="color:#67cdcc">=</span> WAL<span class="token" style="color:#ccc">;</span></code></pre><p>Instead of writing changes directly to the db file, write to a write-ahead-log instead and regularily commit the changes. This allows multiple concurrent readers, and can significantly improve performance.</p><pre style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">pragma synchronous <span class="token" style="color:#67cdcc">=</span> normal<span class="token" style="color:#ccc">;</span></code></pre><p>or even off. normal is still completely corruption safe in WAL mode, and means not every insert/update has to wait for FSYNC. off can cause db corruption though I’ve never had problems. See here: https://www.sqlite.org/pragma.html#pragma_synchronous</p><pre style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">pragma temp_store <span class="token" style="color:#67cdcc">=</span> memory<span class="token" style="color:#ccc">;</span></code></pre><p>stores temporary indices / tables in memory. sqlite automatically <a href="https://www.sqlite.org/tempfiles.html#transient_indices">creates temporary indices</a> for some queries. Not sure how much this one helps.</p><pre style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">pragma mmap_size <span class="token" style="color:#67cdcc">=</span> <span class="token" style="color:#f08d49">30000000000</span><span class="token" style="color:#ccc">;</span></code></pre><p>Uses memory mapping instead of read/write calls when db is &lt; mmap_size. Less syscalls, and pages and caches will be managed by the OS, so the performance of this depends on your operating system. Note that it will not use this amount of physical memory, just virtual memory. Should be much faster on at least Linux.</p><pre style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">pragma page_size <span class="token" style="color:#67cdcc">=</span> <span class="token" style="color:#f08d49">32768</span><span class="token" style="color:#ccc">;</span></code></pre><p>this improved performance and db size a lot for me in one project, but that might only be true because i was storing somewhat large blobs in my database and might not be good for other projects where rows are small.</p><h2 id="more-things-that-must-be-run-manually">More things that must be run manually</h2><pre style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">pragma vacuum<span class="token" style="color:#ccc">;</span></code></pre><p>Run once to completely rewrite the db. Very expensive.</p><pre style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">pragma <span class="token" style="color:#cc99cd">optimize</span><span class="token" style="color:#ccc">;</span></code></pre><blockquote><p>To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run <span class="quoted">&quot;<!-- -->PRAGMA optimize<!-- -->&quot;</span> (with no arguments) just before closing each database connection. Long-running applications might also benefit from setting a timer to run <span class="quoted">&quot;<!-- -->PRAGMA optimize<!-- -->&quot;</span> every few hours. https://www.sqlite.org/pragma.html#pragma_optimize</p></blockquote><pre style="color:#ccc;background:#2d2d2d;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code style="color:#ccc;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">pragma auto_vacuum <span class="token" style="color:#67cdcc">=</span> incremental<span class="token" style="color:#ccc">;</span> <span class="token" style="color:#999">-- once on first DB create</span>
pragma incremental_vacuum<span class="token" style="color:#ccc">;</span> <span class="token" style="color:#999">-- regularily</span></code></pre><p>Probably not useful unless you expect your DB to shrink significantly regularily.</p><blockquote><p>The freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages […]. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the VACUUM command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse.</p></blockquote><h2 id="regarding-wal-mode">Regarding WAL mode</h2><p>WAL mode has some issues where depending on the write pattern, the WAL size can grow to infinity, slowing down performance a lot. I think this usually happens when you have lots of writes that lock the table so sqlite never gets to <a href="https://www.sqlite.org/wal.html#ckpt">doing wal_autocheckpoint</a>. There’s a few ways to mitigate this:</p><ol start="1" type="1"><li>Reduce <a href="https://www.sqlite.org/pragma.html#pragma_wal_autocheckpoint">wal_autocheckpoint interval</a>. No guarantees since all autocheckpoints are passive.</li><li>Run <code>pragma wal_checkpoint(full)</code> or <code>pragma wal_checkpoint(truncate)</code> sometimes. With <code>full</code>, the WAL file won’t change size if other processes have the file open but still commit everything so new data will not cause the WAL file to grow. If you run <code>truncate</code> it will block other processes and reset the WAL file to zero bytes. Note that you <em>can</em> run these from a separate process.</li></ol></div><footer class="center w5 f6 tc mt4"><p><a href="https://github.com/phiresky/blog/blob/master/posts/2020/sqlite-performance-tuning.md">View post source on GitHub</a></p></footer><div><script>/* yes, I know... fite me */
  (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
  function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
  e=o.createElement(i);r=o.getElementsByTagName(i)[0];
  e.src='https://www.google-analytics.com/analytics.js';
  r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
  ga('create','UA-39197996-3','auto');ga('send','pageview');
</script></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"default":{"filename":"2020/sqlite-performance-tuning.md","frontmatter":{"references":[],"date":"2020-06-26","csl":"../ieee-with-url.csl","hidden":true,"url2cite-link-output":"sup","title":"SQlite performance tuning - Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second"},"preview":"SQLite is an embedded SQL database that mimics the PostgreSQL query syntax. It’s extremely easy to setup, with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database","content_ast":[{"t":"Para","c":[{"t":"Str","c":"SQLite is an embedded SQL database that mimics the PostgreSQL query syntax. It’s extremely easy to setup, with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only two files you can easily copy or move around. You can still connect to and query the same database concurrently with multiple processes, though only one write operation can happen at the same time."}]},{"t":"Para","c":[{"t":"Str","c":"SQLite is often seen as only a toy database only suitable for databases with a few hundred entries and without any performance requirements, but you can scale a SQLite database to multiple GByte in size and many concurrent readers while maintaining high performance by applying the below optimizations."}]},{"t":"Header","c":[2,["run-these-every-time-you-connect-to-the-db",[],[]],[{"t":"Str","c":"Run these every time you connect to the db"}]]},{"t":"Para","c":[{"t":"Str","c":"Some of these are applied permanently, but others are reset on new connection, so it’s recommended to run all of these each time you connect to the database."}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma journal_mode = WAL;"]},{"t":"Para","c":[{"t":"Str","c":"Instead of writing changes directly to the db file, write to a write-ahead-log instead and regularily commit the changes. This allows multiple concurrent readers, and can significantly improve performance."}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma synchronous = normal;"]},{"t":"Para","c":[{"t":"Str","c":"or even off. normal is still completely corruption safe in WAL mode, and means not every insert/update has to wait for FSYNC. off can cause db corruption though I’ve never had problems. See here: https://www.sqlite.org/pragma.html#pragma_synchronous"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma temp_store = memory;"]},{"t":"Para","c":[{"t":"Str","c":"stores temporary indices / tables in memory. sqlite automatically "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"creates temporary indices"}],["https://www.sqlite.org/tempfiles.html#transient_indices",""]]},{"t":"Str","c":" for some queries. Not sure how much this one helps."}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma mmap_size = 30000000000;"]},{"t":"Para","c":[{"t":"Str","c":"Uses memory mapping instead of read/write calls when db is \u003c mmap_size. Less syscalls, and pages and caches will be managed by the OS, so the performance of this depends on your operating system. Note that it will not use this amount of physical memory, just virtual memory. Should be much faster on at least Linux."}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma page_size = 32768;"]},{"t":"Para","c":[{"t":"Str","c":"this improved performance and db size a lot for me in one project, but that might only be true because i was storing somewhat large blobs in my database and might not be good for other projects where rows are small."}]},{"t":"Header","c":[2,["more-things-that-must-be-run-manually",[],[]],[{"t":"Str","c":"More things that must be run manually"}]]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma vacuum;"]},{"t":"Para","c":[{"t":"Str","c":"Run once to completely rewrite the db. Very expensive."}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma optimize;"]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" (with no arguments) just before closing each database connection. Long-running applications might also benefit from setting a timer to run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" every few hours. https://www.sqlite.org/pragma.html#pragma_optimize"}]}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma auto_vacuum = incremental; -- once on first DB create\npragma incremental_vacuum; -- regularily"]},{"t":"Para","c":[{"t":"Str","c":"Probably not useful unless you expect your DB to shrink significantly regularily."}]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"The freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages […]. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the VACUUM command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse."}]}]},{"t":"Header","c":[2,["regarding-wal-mode",[],[]],[{"t":"Str","c":"Regarding WAL mode"}]]},{"t":"Para","c":[{"t":"Str","c":"WAL mode has some issues where depending on the write pattern, the WAL size can grow to infinity, slowing down performance a lot. I think this usually happens when you have lots of writes that lock the table so sqlite never gets to "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"doing wal_autocheckpoint"}],["https://www.sqlite.org/wal.html#ckpt",""]]},{"t":"Str","c":". There’s a few ways to mitigate this:"}]},{"t":"OrderedList","c":[[1,{"t":"Decimal"},{"t":"Period"}],[[{"t":"Plain","c":[{"t":"Str","c":"Reduce "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"wal_autocheckpoint interval"}],["https://www.sqlite.org/pragma.html#pragma_wal_autocheckpoint",""]]},{"t":"Str","c":". No guarantees since all autocheckpoints are passive."}]}],[{"t":"Plain","c":[{"t":"Str","c":"Run "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(full)"]},{"t":"Str","c":" or "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(truncate)"]},{"t":"Str","c":" sometimes. With "},{"t":"Code","c":[["",[],[]],"full"]},{"t":"Str","c":", the WAL file won’t change size if other processes have the file open but still commit everything so new data will not cause the WAL file to grow. If you run "},{"t":"Code","c":[["",[],[]],"truncate"]},{"t":"Str","c":" it will block other processes and reset the WAL file to zero bytes. Note that you "},{"t":"Emph","c":[{"t":"Str","c":"can"}]},{"t":"Str","c":" run these from a separate process."}]}]]]}]},"filename":"2020/sqlite-performance-tuning.md","frontmatter":{"references":[],"date":"2020-06-26","csl":"../ieee-with-url.csl","hidden":true,"url2cite-link-output":"sup","title":"SQlite performance tuning - Scaling SQLite databases to many concurrent readers and multiple gigabytes while maintaining 100k SELECTs per second"},"preview":"SQLite is an embedded SQL database that mimics the PostgreSQL query syntax. It’s extremely easy to setup, with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database","content_ast":[{"t":"Para","c":[{"t":"Str","c":"SQLite is an embedded SQL database that mimics the PostgreSQL query syntax. It’s extremely easy to setup, with libraries existing for basically all common programming languages. It doesn’t need any server setup or configuration since the SQL logic is run in the host process, and the database consists of only two files you can easily copy or move around. You can still connect to and query the same database concurrently with multiple processes, though only one write operation can happen at the same time."}]},{"t":"Para","c":[{"t":"Str","c":"SQLite is often seen as only a toy database only suitable for databases with a few hundred entries and without any performance requirements, but you can scale a SQLite database to multiple GByte in size and many concurrent readers while maintaining high performance by applying the below optimizations."}]},{"t":"Header","c":[2,["run-these-every-time-you-connect-to-the-db",[],[]],[{"t":"Str","c":"Run these every time you connect to the db"}]]},{"t":"Para","c":[{"t":"Str","c":"Some of these are applied permanently, but others are reset on new connection, so it’s recommended to run all of these each time you connect to the database."}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma journal_mode = WAL;"]},{"t":"Para","c":[{"t":"Str","c":"Instead of writing changes directly to the db file, write to a write-ahead-log instead and regularily commit the changes. This allows multiple concurrent readers, and can significantly improve performance."}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma synchronous = normal;"]},{"t":"Para","c":[{"t":"Str","c":"or even off. normal is still completely corruption safe in WAL mode, and means not every insert/update has to wait for FSYNC. off can cause db corruption though I’ve never had problems. See here: https://www.sqlite.org/pragma.html#pragma_synchronous"}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma temp_store = memory;"]},{"t":"Para","c":[{"t":"Str","c":"stores temporary indices / tables in memory. sqlite automatically "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"creates temporary indices"}],["https://www.sqlite.org/tempfiles.html#transient_indices",""]]},{"t":"Str","c":" for some queries. Not sure how much this one helps."}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma mmap_size = 30000000000;"]},{"t":"Para","c":[{"t":"Str","c":"Uses memory mapping instead of read/write calls when db is \u003c mmap_size. Less syscalls, and pages and caches will be managed by the OS, so the performance of this depends on your operating system. Note that it will not use this amount of physical memory, just virtual memory. Should be much faster on at least Linux."}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma page_size = 32768;"]},{"t":"Para","c":[{"t":"Str","c":"this improved performance and db size a lot for me in one project, but that might only be true because i was storing somewhat large blobs in my database and might not be good for other projects where rows are small."}]},{"t":"Header","c":[2,["more-things-that-must-be-run-manually",[],[]],[{"t":"Str","c":"More things that must be run manually"}]]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma vacuum;"]},{"t":"Para","c":[{"t":"Str","c":"Run once to completely rewrite the db. Very expensive."}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma optimize;"]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" (with no arguments) just before closing each database connection. Long-running applications might also benefit from setting a timer to run "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"PRAGMA optimize"}]]},{"t":"Str","c":" every few hours. https://www.sqlite.org/pragma.html#pragma_optimize"}]}]},{"t":"CodeBlock","c":[["",["sql"],[]],"pragma auto_vacuum = incremental; -- once on first DB create\npragma incremental_vacuum; -- regularily"]},{"t":"Para","c":[{"t":"Str","c":"Probably not useful unless you expect your DB to shrink significantly regularily."}]},{"t":"BlockQuote","c":[{"t":"Para","c":[{"t":"Str","c":"The freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages […]. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the VACUUM command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse."}]}]},{"t":"Header","c":[2,["regarding-wal-mode",[],[]],[{"t":"Str","c":"Regarding WAL mode"}]]},{"t":"Para","c":[{"t":"Str","c":"WAL mode has some issues where depending on the write pattern, the WAL size can grow to infinity, slowing down performance a lot. I think this usually happens when you have lots of writes that lock the table so sqlite never gets to "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"doing wal_autocheckpoint"}],["https://www.sqlite.org/wal.html#ckpt",""]]},{"t":"Str","c":". There’s a few ways to mitigate this:"}]},{"t":"OrderedList","c":[[1,{"t":"Decimal"},{"t":"Period"}],[[{"t":"Plain","c":[{"t":"Str","c":"Reduce "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"wal_autocheckpoint interval"}],["https://www.sqlite.org/pragma.html#pragma_wal_autocheckpoint",""]]},{"t":"Str","c":". No guarantees since all autocheckpoints are passive."}]}],[{"t":"Plain","c":[{"t":"Str","c":"Run "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(full)"]},{"t":"Str","c":" or "},{"t":"Code","c":[["",[],[]],"pragma wal_checkpoint(truncate)"]},{"t":"Str","c":" sometimes. With "},{"t":"Code","c":[["",[],[]],"full"]},{"t":"Str","c":", the WAL file won’t change size if other processes have the file open but still commit everything so new data will not cause the WAL file to grow. If you run "},{"t":"Code","c":[["",[],[]],"truncate"]},{"t":"Str","c":" it will block other processes and reset the WAL file to zero bytes. Note that you "},{"t":"Emph","c":[{"t":"Str","c":"can"}]},{"t":"Str","c":" run these from a separate process."}]}]]]}]}}},"page":"/post","query":{"slug":"2020/sqlite-performance-tuning"},"buildId":"w6yMeJS-Ar_5gYMMOCrtm","assetPrefix":"/blog","nextExport":true,"isFallback":false,"gip":true}</script><script nomodule="" src="/blog/_next/static/runtime/polyfills-84740ca5db313ed522c6.js"></script><script async="" data-next-page="/_app" src="/blog/_next/static/w6yMeJS-Ar_5gYMMOCrtm/pages/_app.js"></script><script async="" data-next-page="/post" src="/blog/_next/static/w6yMeJS-Ar_5gYMMOCrtm/pages/post.js"></script><script src="/blog/_next/static/runtime/webpack-51670fedc58181f2a5ba.js" async=""></script><script src="/blog/_next/static/chunks/framework.863892844f7f82998c77.js" async=""></script><script src="/blog/_next/static/chunks/commons.e37083b02f3da808fc65.js" async=""></script><script src="/blog/_next/static/chunks/styles.0bf15041ddf6570a62b9.js" async=""></script><script src="/blog/_next/static/runtime/main-d9959e011352fa92f435.js" async=""></script><script src="/blog/_next/static/chunks/a1bc03cf.11076168cfbd5b32b98d.js" async=""></script><script src="/blog/_next/static/chunks/06447f4e.4bc253d795120c94810e.js" async=""></script><script src="/blog/_next/static/chunks/c78d26b1.64425fbfab6f2d75c31a.js" async=""></script><script src="/blog/_next/static/chunks/15220c3dd78d48351fd3e78a3f003361180e4b66.ec41676bcf086898de3d.js" async=""></script><script src="/blog/_next/static/w6yMeJS-Ar_5gYMMOCrtm/_buildManifest.js" async=""></script><script src="/blog/_next/static/w6yMeJS-Ar_5gYMMOCrtm/_ssgManifest.js" async=""></script></body></html>