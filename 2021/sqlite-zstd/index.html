<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>sqlite-zstd: Transparent row-level compression for SQLite - phiresky&#x27;s blog</title><meta name="description" content="For my incomplete time-tracking tool, I store snapshots of the windows I have open in order to later analyze what I spend my time on. This data is pretty redundant - the open program doesn’t change that much, but I still want a snapshot every 30 seconds. Story? There’s a few solutions I could think "/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="alternate" type="application/rss+xml" title="RSS feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/rss.xml"/><link rel="alternate" type="application/atom+xml" title="Atom feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/atom.xml"/><link rel="alternate" type="application/json" title="JSON feed of phiresky&#x27;s blog" href="https://phiresky.github.io/blog/feed.json"/><style>
          body {
            font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
          }
      </style><meta name="next-head-count" content="8"/><link rel="preload" href="/blog/_next/static/css/d142d8dffeea0e3e7918.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/d142d8dffeea0e3e7918.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/78a73292fe5dfabb752a.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/78a73292fe5dfabb752a.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/main-a96ffcab9ac3f714966d.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/webpack-616848fc9016435d0c8a.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework.60867bcc68b986f6e60d.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons.08ddd7455f4143b98f8d.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-3bdda458aa4ad17304fc.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/06447f4e.e11bbf63b9bfcd126107.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/c78d26b1.84adfeb932354ef9a95e.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/768876d20c0ee2e540736d254e2790c53bb785f0.2a06644f067446519e2a.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/post-4163277423727bcbd85f.js" as="script"/></head><body><div id="__next"><div class="jsx-2809278127"><div><main class="lh-copy"><div class="relative tc bg-dark-gray"><div class="mw7 center white"><div class="pv4"><h1 class="f2 normal lh-title ma0 pa0"><a class="white no-underline" href="/blog/">phiresky&#x27;s blog</a></h1><h4 class="normal o-70 ma0 pt2 pb3 ph1">About my personal projects and other stuff</h4><div><a href="https://phiresky.github.io/blog/" class="dib f6 white no-underline pa1 ma1">Blog</a><a href="https://github.com/phiresky/" class="dib f6 white no-underline pa1 ma1">GitHub</a></div></div></div></div><div class="jsx-2809278127 content center mw7 pa3 pa4-ns"><h1 class="jsx-2809278127 mt0 lh-title mb1">sqlite-zstd: Transparent row-level compression for SQLite</h1><small class="db ttu o-40"><time dateTime="2021-01-24T00:00:00.000Z">Jan 24, 2021</time></small><p>For my <a href="https://github.com/phiresky/timetrackrs">incomplete time-tracking tool</a>, I store snapshots of the windows I have open in order to later analyze what I spend my time on. This data is pretty redundant - the open program doesn’t change that much, but I still want a snapshot every 30 seconds. <s>Story</s>?</p><p>There’s a few solutions I could think of when you have compressible data in your database:</p><ul><li><p>Just store the data compressed individually. On insert, compress(data), on every select decompress it.</p><p>This is easy to implement and easy to use. But it’s also not that effective, especially if your column contains JSON data since JSON stores the keys together with the data, separately in every row.</p></li><li><p>Split the database into separate files (for example weekly), then compress the older partitions into single files.</p><p>If you need to access older data, simply decompress the whole week of data to RAM, then read from that database. This would work okay for my use case since it’s pretty much append-only time-series data; older data is not read often, and when it is it is read pretty sequentially.</p><p>This idea is kind of similar to table partitioning and tablespaces in PostgreSQL. In SQLite you can attach multiple database files into a single instance using <code>ATTACH DATABASE</code>, and then join across tables of the different files.</p></li></ul><p>create table compressible(id integer primary key not null, data text); insert into compressible(data) select case abs(random() % 2) when true then <span class="quoted">&#x27;<!-- -->{<span class="quoted">&quot;<!-- -->foobar<!-- -->&quot;</span>: <span class="quoted">&quot;<!-- -->hello world<!-- -->&quot;</span>}<!-- -->&#x27;</span> when false then <span class="quoted">&#x27;<!-- -->{<span class="quoted">&quot;<!-- -->yello<!-- -->&quot;</span>: <span class="quoted">&quot;<!-- -->nopify<!-- -->&quot;</span>}<!-- -->&#x27;</span> end from generate_series(1, 1000000);</p></div><footer class="center w5 f6 tc mt4"><p><a href="https://github.com/phiresky/blog/blob/master/posts/2021/sqlite-zstd.md">View post source on GitHub</a></p></footer><div><script>/* yes, I know... fite me */
  (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
  function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
  e=o.createElement(i);r=o.getElementsByTagName(i)[0];
  e.src='https://www.google-analytics.com/analytics.js';
  r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
  ga('create','UA-39197996-3','auto');ga('send','pageview');
</script></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"default":{"filename":"2021/sqlite-zstd.md","frontmatter":{"csl":"../ieee-with-url.csl","date":"2021-01-24","hidden":true,"references":[],"subtitle":"","title":"sqlite-zstd: Transparent row-level compression for SQLite","url2cite-link-output":"sup"},"preview":"For my incomplete time-tracking tool, I store snapshots of the windows I have open in order to later analyze what I spend my time on. This data is pretty redundant - the open program doesn’t change that much, but I still want a snapshot every 30 seconds. Story? There’s a few solutions I could think ","content_ast":[{"t":"Para","c":[{"t":"Str","c":"For my "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"incomplete time-tracking tool"}],["https://github.com/phiresky/timetrackrs",""]]},{"t":"Str","c":", I store snapshots of the windows I have open in order to later analyze what I spend my time on. This data is pretty redundant - the open program doesn’t change that much, but I still want a snapshot every 30 seconds. "},{"t":"Strikeout","c":[{"t":"Str","c":"Story"}]},{"t":"Str","c":"?"}]},{"t":"Para","c":[{"t":"Str","c":"There’s a few solutions I could think of when you have compressible data in your database:"}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Str","c":"Just store the data compressed individually. On insert, compress(data), on every select decompress it."}]},{"t":"Para","c":[{"t":"Str","c":"This is easy to implement and easy to use. But it’s also not that effective, especially if your column contains JSON data since JSON stores the keys together with the data, separately in every row."}]}],[{"t":"Para","c":[{"t":"Str","c":"Split the database into separate files (for example weekly), then compress the older partitions into single files."}]},{"t":"Para","c":[{"t":"Str","c":"If you need to access older data, simply decompress the whole week of data to RAM, then read from that database. This would work okay for my use case since it’s pretty much append-only time-series data; older data is not read often, and when it is it is read pretty sequentially."}]},{"t":"Para","c":[{"t":"Str","c":"This idea is kind of similar to table partitioning and tablespaces in PostgreSQL. In SQLite you can attach multiple database files into a single instance using "},{"t":"Code","c":[["",[],[]],"ATTACH DATABASE"]},{"t":"Str","c":", and then join across tables of the different files."}]}]]},{"t":"Para","c":[{"t":"Str","c":"create table compressible(id integer primary key not null, data text); insert into compressible(data) select case abs(random() % 2) when true then "},{"t":"Quoted","c":[{"t":"SingleQuote"},[{"t":"Str","c":"{"},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"foobar"}]]},{"t":"Str","c":": "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"hello world"}]]},{"t":"Str","c":"}"}]]},{"t":"Str","c":" when false then "},{"t":"Quoted","c":[{"t":"SingleQuote"},[{"t":"Str","c":"{"},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"yello"}]]},{"t":"Str","c":": "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"nopify"}]]},{"t":"Str","c":"}"}]]},{"t":"Str","c":" end from generate_series(1, 1000000);"}]}]},"filename":"2021/sqlite-zstd.md","frontmatter":{"csl":"../ieee-with-url.csl","date":"2021-01-24","hidden":true,"references":[],"subtitle":"","title":"sqlite-zstd: Transparent row-level compression for SQLite","url2cite-link-output":"sup"},"preview":"For my incomplete time-tracking tool, I store snapshots of the windows I have open in order to later analyze what I spend my time on. This data is pretty redundant - the open program doesn’t change that much, but I still want a snapshot every 30 seconds. Story? There’s a few solutions I could think ","content_ast":[{"t":"Para","c":[{"t":"Str","c":"For my "},{"t":"Link","c":[["",[],[]],[{"t":"Str","c":"incomplete time-tracking tool"}],["https://github.com/phiresky/timetrackrs",""]]},{"t":"Str","c":", I store snapshots of the windows I have open in order to later analyze what I spend my time on. This data is pretty redundant - the open program doesn’t change that much, but I still want a snapshot every 30 seconds. "},{"t":"Strikeout","c":[{"t":"Str","c":"Story"}]},{"t":"Str","c":"?"}]},{"t":"Para","c":[{"t":"Str","c":"There’s a few solutions I could think of when you have compressible data in your database:"}]},{"t":"BulletList","c":[[{"t":"Para","c":[{"t":"Str","c":"Just store the data compressed individually. On insert, compress(data), on every select decompress it."}]},{"t":"Para","c":[{"t":"Str","c":"This is easy to implement and easy to use. But it’s also not that effective, especially if your column contains JSON data since JSON stores the keys together with the data, separately in every row."}]}],[{"t":"Para","c":[{"t":"Str","c":"Split the database into separate files (for example weekly), then compress the older partitions into single files."}]},{"t":"Para","c":[{"t":"Str","c":"If you need to access older data, simply decompress the whole week of data to RAM, then read from that database. This would work okay for my use case since it’s pretty much append-only time-series data; older data is not read often, and when it is it is read pretty sequentially."}]},{"t":"Para","c":[{"t":"Str","c":"This idea is kind of similar to table partitioning and tablespaces in PostgreSQL. In SQLite you can attach multiple database files into a single instance using "},{"t":"Code","c":[["",[],[]],"ATTACH DATABASE"]},{"t":"Str","c":", and then join across tables of the different files."}]}]]},{"t":"Para","c":[{"t":"Str","c":"create table compressible(id integer primary key not null, data text); insert into compressible(data) select case abs(random() % 2) when true then "},{"t":"Quoted","c":[{"t":"SingleQuote"},[{"t":"Str","c":"{"},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"foobar"}]]},{"t":"Str","c":": "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"hello world"}]]},{"t":"Str","c":"}"}]]},{"t":"Str","c":" when false then "},{"t":"Quoted","c":[{"t":"SingleQuote"},[{"t":"Str","c":"{"},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"yello"}]]},{"t":"Str","c":": "},{"t":"Quoted","c":[{"t":"DoubleQuote"},[{"t":"Str","c":"nopify"}]]},{"t":"Str","c":"}"}]]},{"t":"Str","c":" end from generate_series(1, 1000000);"}]}]}}},"page":"/post","query":{"slug":"2021/sqlite-zstd"},"buildId":"RMhU4dOjureGSC3lY6iOI","assetPrefix":"/blog","nextExport":true,"isFallback":false,"gip":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-af56e6617f887d19013e.js"></script><script src="/blog/_next/static/chunks/main-a96ffcab9ac3f714966d.js" async=""></script><script src="/blog/_next/static/chunks/webpack-616848fc9016435d0c8a.js" async=""></script><script src="/blog/_next/static/chunks/framework.60867bcc68b986f6e60d.js" async=""></script><script src="/blog/_next/static/chunks/commons.08ddd7455f4143b98f8d.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-3bdda458aa4ad17304fc.js" async=""></script><script src="/blog/_next/static/chunks/06447f4e.e11bbf63b9bfcd126107.js" async=""></script><script src="/blog/_next/static/chunks/c78d26b1.84adfeb932354ef9a95e.js" async=""></script><script src="/blog/_next/static/chunks/768876d20c0ee2e540736d254e2790c53bb785f0.2a06644f067446519e2a.js" async=""></script><script src="/blog/_next/static/chunks/pages/post-4163277423727bcbd85f.js" async=""></script><script src="/blog/_next/static/RMhU4dOjureGSC3lY6iOI/_buildManifest.js" async=""></script><script src="/blog/_next/static/RMhU4dOjureGSC3lY6iOI/_ssgManifest.js" async=""></script></body></html>