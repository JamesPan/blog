(window.webpackJsonp=window.webpackJsonp||[]).push([["98d3"],{"3niX":function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.flush=function(){var e=u.cssRules();return u.flush(),e},t.default=void 0;var n,o=r("q1tI");function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function s(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function a(e,t){return!t||"object"!==i(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function l(e){return(l=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function c(e,t){return(c=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}var u=new(((n=r("SevZ"))&&n.__esModule?n:{default:n}).default),p=function(e){function t(e){var r;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),(r=a(this,l(t).call(this,e))).prevProps={},r}var r,n,i;return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&c(e,t)}(t,o.Component),r=t,i=[{key:"dynamic",value:function(e){return e.map(function(e){var t=e[0],r=e[1];return u.computeId(t,r)}).join(" ")}}],(n=[{key:"shouldComponentUpdate",value:function(e){return this.props.id!==e.id||String(this.props.dynamic)!==String(e.dynamic)}},{key:"componentWillUnmount",value:function(){u.remove(this.props)}},{key:"render",value:function(){return this.shouldComponentUpdate(this.prevProps)&&(this.prevProps.id&&u.remove(this.prevProps),u.add(this.props),this.prevProps=this.props),null}}])&&s(r.prototype,n),i&&s(r,i),t}();t.default=p},"4jRS":function(e,t,r){"use strict";r.r(t);var n=r("MX0m"),o=r.n(n),i=r("q1tI"),s=r.n(i),a=r("nOHt"),l=r("NqE+"),c=r("vivp");function u(e){return s.a.createElement("div",{className:"content center mw6 pa3 pa4-ns"},s.a.createElement("h1",{className:"mt0 lh-title"},e.title),s.a.createElement("div",{dangerouslySetInnerHTML:{__html:e.bodyHtml}}))}t.default=Object(a.withRouter)(function(e){var t={};return e.router.query&&e.router.query.fullUrl&&(t=r("U5sb")("./content".concat(e.router.query.fullUrl,".json"))),s.a.createElement("div",{className:"jsx-1452997703"},s.a.createElement(o.a,{id:"1452997703"},[".content a{color:#0365a5;-webkit-text-decoration:none;text-decoration:none;border-bottom:1px solid #dfdfdf;-webkit-transition:all 300ms ease;transition:all 300ms ease;}","a:hover,a:focus{border-bottom-color:currentColor;}","code{background-color:#eee;line-height:1;border-radius:2px;padding:1px;}","code:not(.hljs){border:1px solid #ddd;}"]),s.a.createElement(l.a,{siteTitle:"".concat(c.siteTitle," - ").concat(t.title),heroTitle:c.siteTitle,description:c.description,stylesheets:c.stylesheets,topLinks:c.topLinks,backgroundClass:c.backgroundClass,body:u(t),copyright:c.copyright,siteId:c.siteId}))})},"8oxB":function(e,t){var r,n,o=e.exports={};function i(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}function a(e){if(r===setTimeout)return setTimeout(e,0);if((r===i||!r)&&setTimeout)return r=setTimeout,setTimeout(e,0);try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:i}catch(e){r=i}try{n="function"==typeof clearTimeout?clearTimeout:s}catch(e){n=s}}();var l,c=[],u=!1,p=-1;function h(){u&&l&&(u=!1,l.length?c=l.concat(c):p=-1,c.length&&d())}function d(){if(!u){var e=a(h);u=!0;for(var t=c.length;t;){for(l=c,c=[];++p<t;)l&&l[p].run();p=-1,t=c.length}l=null,u=!1,function(e){if(n===clearTimeout)return clearTimeout(e);if((n===s||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}(e)}}function f(e,t){this.fun=e,this.array=t}function m(){}o.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];c.push(new f(e,t)),1!==c.length||u||a(d)},f.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=m,o.addListener=m,o.once=m,o.off=m,o.removeListener=m,o.removeAllListeners=m,o.emit=m,o.prependListener=m,o.prependOnceListener=m,o.listeners=function(e){return[]},o.binding=function(e){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(e){throw new Error("process.chdir is not supported")},o.umask=function(){return 0}},"9kyW":function(e,t,r){"use strict";e.exports=function(e){for(var t=5381,r=e.length;r;)t=33*t^e.charCodeAt(--r);return t>>>0}},MX0m:function(e,t,r){e.exports=r("3niX")},SXBd:function(e,t,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/post",function(){var e=r("4jRS");return{page:e.default||e}}])},SevZ:function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=i(r("9kyW")),o=i(r("bVZc"));function i(e){return e&&e.__esModule?e:{default:e}}function s(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var a=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.styleSheet,n=void 0===r?null:r,i=t.optimizeForSpeed,s=void 0!==i&&i,a=t.isBrowser,l=void 0===a?"undefined"!=typeof window:a;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this._sheet=n||new o.default({name:"styled-jsx",optimizeForSpeed:s}),this._sheet.inject(),n&&"boolean"==typeof s&&(this._sheet.setOptimizeForSpeed(s),this._optimizeForSpeed=this._sheet.isOptimizeForSpeed()),this._isBrowser=l,this._fromServer=void 0,this._indices={},this._instancesCounts={},this.computeId=this.createComputeId(),this.computeSelector=this.createComputeSelector()}var t,r,i;return t=e,(r=[{key:"add",value:function(e){var t=this;void 0===this._optimizeForSpeed&&(this._optimizeForSpeed=Array.isArray(e.children),this._sheet.setOptimizeForSpeed(this._optimizeForSpeed),this._optimizeForSpeed=this._sheet.isOptimizeForSpeed()),this._isBrowser&&!this._fromServer&&(this._fromServer=this.selectFromServer(),this._instancesCounts=Object.keys(this._fromServer).reduce(function(e,t){return e[t]=0,e},{}));var r=this.getIdAndRules(e),n=r.styleId,o=r.rules;if(n in this._instancesCounts)this._instancesCounts[n]+=1;else{var i=o.map(function(e){return t._sheet.insertRule(e)}).filter(function(e){return-1!==e});this._indices[n]=i,this._instancesCounts[n]=1}}},{key:"remove",value:function(e){var t=this,r=this.getIdAndRules(e).styleId;if(function(e,t){if(!e)throw new Error("StyleSheetRegistry: ".concat(t,"."))}(r in this._instancesCounts,"styleId: `".concat(r,"` not found")),this._instancesCounts[r]-=1,this._instancesCounts[r]<1){var n=this._fromServer&&this._fromServer[r];n?(n.parentNode.removeChild(n),delete this._fromServer[r]):(this._indices[r].forEach(function(e){return t._sheet.deleteRule(e)}),delete this._indices[r]),delete this._instancesCounts[r]}}},{key:"update",value:function(e,t){this.add(t),this.remove(e)}},{key:"flush",value:function(){this._sheet.flush(),this._sheet.inject(),this._fromServer=void 0,this._indices={},this._instancesCounts={},this.computeId=this.createComputeId(),this.computeSelector=this.createComputeSelector()}},{key:"cssRules",value:function(){var e=this,t=this._fromServer?Object.keys(this._fromServer).map(function(t){return[t,e._fromServer[t]]}):[],r=this._sheet.cssRules();return t.concat(Object.keys(this._indices).map(function(t){return[t,e._indices[t].map(function(e){return r[e].cssText}).join(e._optimizeForSpeed?"":"\n")]}).filter(function(e){return Boolean(e[1])}))}},{key:"createComputeId",value:function(){var e={};return function(t,r){if(!r)return"jsx-".concat(t);var o=String(r),i=t+o;return e[i]||(e[i]="jsx-".concat((0,n.default)("".concat(t,"-").concat(o)))),e[i]}}},{key:"createComputeSelector",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:/__jsx-style-dynamic-selector/g,t={};return function(r,n){this._isBrowser||(n=n.replace(/\/style/gi,"\\/style"));var o=r+n;return t[o]||(t[o]=n.replace(e,r)),t[o]}}},{key:"getIdAndRules",value:function(e){var t=this,r=e.children,n=e.dynamic,o=e.id;if(n){var i=this.computeId(o,n);return{styleId:i,rules:Array.isArray(r)?r.map(function(e){return t.computeSelector(i,e)}):[this.computeSelector(i,r)]}}return{styleId:this.computeId(o),rules:Array.isArray(r)?r:[r]}}},{key:"selectFromServer",value:function(){return Array.prototype.slice.call(document.querySelectorAll('[id^="__jsx-"]')).reduce(function(e,t){return e[t.id.slice(2)]=t,e},{})}}])&&s(t.prototype,r),i&&s(t,i),e}();t.default=a},U5sb:function(e,t,r){var n={"./content/2019/rga.json":"wzhO","./content/custom-post.json":"zeTH","./content/index.json":"vivp","./content/rga.json":"mWBJ","./content/summary.json":"2LNF"};function o(e){var t=i(e);return r(t)}function i(e){var t=n[e];if(!(t+1)){var r=new Error("Cannot find module '"+e+"'");throw r.code="MODULE_NOT_FOUND",r}return t}o.keys=function(){return Object.keys(n)},o.resolve=i,e.exports=o,o.id="U5sb"},bVZc:function(e,t,r){"use strict";(function(e){function r(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=e.env&&!0,o=function(e){return"[object String]"===Object.prototype.toString.call(e)},i=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.name,i=void 0===r?"stylesheet":r,a=t.optimizeForSpeed,l=void 0===a?n:a,c=t.isBrowser,u=void 0===c?"undefined"!=typeof window:c;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),s(o(i),"`name` must be a string"),this._name=i,this._deletedRulePlaceholder="#".concat(i,"-deleted-rule____{}"),s("boolean"==typeof l,"`optimizeForSpeed` must be a boolean"),this._optimizeForSpeed=l,this._isBrowser=u,this._serverSheet=void 0,this._tags=[],this._injected=!1,this._rulesCount=0;var p=this._isBrowser&&document.querySelector('meta[property="csp-nonce"]');this._nonce=p?p.getAttribute("content"):null}var t,i,a;return t=e,(i=[{key:"setOptimizeForSpeed",value:function(e){s("boolean"==typeof e,"`setOptimizeForSpeed` accepts a boolean"),s(0===this._rulesCount,"optimizeForSpeed cannot be when rules have already been inserted"),this.flush(),this._optimizeForSpeed=e,this.inject()}},{key:"isOptimizeForSpeed",value:function(){return this._optimizeForSpeed}},{key:"inject",value:function(){var e=this;if(s(!this._injected,"sheet already injected"),this._injected=!0,this._isBrowser&&this._optimizeForSpeed)return this._tags[0]=this.makeStyleTag(this._name),this._optimizeForSpeed="insertRule"in this.getSheet(),void(this._optimizeForSpeed||(n||console.warn("StyleSheet: optimizeForSpeed mode not supported falling back to standard mode."),this.flush(),this._injected=!0));this._serverSheet={cssRules:[],insertRule:function(t,r){return"number"==typeof r?e._serverSheet.cssRules[r]={cssText:t}:e._serverSheet.cssRules.push({cssText:t}),r},deleteRule:function(t){e._serverSheet.cssRules[t]=null}}}},{key:"getSheetForTag",value:function(e){if(e.sheet)return e.sheet;for(var t=0;t<document.styleSheets.length;t++)if(document.styleSheets[t].ownerNode===e)return document.styleSheets[t]}},{key:"getSheet",value:function(){return this.getSheetForTag(this._tags[this._tags.length-1])}},{key:"insertRule",value:function(e,t){if(s(o(e),"`insertRule` accepts only strings"),!this._isBrowser)return"number"!=typeof t&&(t=this._serverSheet.cssRules.length),this._serverSheet.insertRule(e,t),this._rulesCount++;if(this._optimizeForSpeed){var r=this.getSheet();"number"!=typeof t&&(t=r.cssRules.length);try{r.insertRule(e,t)}catch(a){return n||console.warn("StyleSheet: illegal rule: \n\n".concat(e,"\n\nSee https://stackoverflow.com/q/20007992 for more info")),-1}}else{var i=this._tags[t];this._tags.push(this.makeStyleTag(this._name,e,i))}return this._rulesCount++}},{key:"replaceRule",value:function(e,t){if(this._optimizeForSpeed||!this._isBrowser){var r=this._isBrowser?this.getSheet():this._serverSheet;if(t.trim()||(t=this._deletedRulePlaceholder),!r.cssRules[e])return e;r.deleteRule(e);try{r.insertRule(t,e)}catch(i){n||console.warn("StyleSheet: illegal rule: \n\n".concat(t,"\n\nSee https://stackoverflow.com/q/20007992 for more info")),r.insertRule(this._deletedRulePlaceholder,e)}}else{var o=this._tags[e];s(o,"old rule at index `".concat(e,"` not found")),o.textContent=t}return e}},{key:"deleteRule",value:function(e){if(this._isBrowser)if(this._optimizeForSpeed)this.replaceRule(e,"");else{var t=this._tags[e];s(t,"rule at index `".concat(e,"` not found")),t.parentNode.removeChild(t),this._tags[e]=null}else this._serverSheet.deleteRule(e)}},{key:"flush",value:function(){this._injected=!1,this._rulesCount=0,this._isBrowser?(this._tags.forEach(function(e){return e&&e.parentNode.removeChild(e)}),this._tags=[]):this._serverSheet.cssRules=[]}},{key:"cssRules",value:function(){var e=this;return this._isBrowser?this._tags.reduce(function(t,r){return r?t=t.concat(e.getSheetForTag(r).cssRules.map(function(t){return t.cssText===e._deletedRulePlaceholder?null:t})):t.push(null),t},[]):this._serverSheet.cssRules}},{key:"makeStyleTag",value:function(e,t,r){t&&s(o(t),"makeStyleTag acceps only strings as second parameter");var n=document.createElement("style");this._nonce&&n.setAttribute("nonce",this._nonce),n.type="text/css",n.setAttribute("data-".concat(e),""),t&&n.appendChild(document.createTextNode(t));var i=document.head||document.getElementsByTagName("head")[0];return r?i.insertBefore(n,r):i.appendChild(n),n}},{key:"length",get:function(){return this._rulesCount}}])&&r(t.prototype,i),a&&r(t,a),e}();function s(e,t){if(!e)throw new Error("StyleSheet: ".concat(t,"."))}t.default=i}).call(this,r("8oxB"))},mWBJ:function(e){e.exports={title:"\\[\\[draft]] rga - ripgrep, but also search in PDFs, E-Books, Office documents, zip, tar.gz, etc",date:"2019-06-13T00:00:00.000Z",bodyContent:"rga is a line-oriented search tool that allows you to look for a regex in a multitude of file types. It is a wrapper around the awesome [ripgrep] that enables it to search in pdf, docx, pptx, movie subtitles (mkv, mp4), sqlite, etc.\n\n[![Linux build status](https://api.travis-ci.org/phiresky/ripgrep_all.svg)](https://travis-ci.org/phiresky/ripgrep_all)\n[![Crates.io](https://img.shields.io/crates/v/ripgrep_all.svg)](https://crates.io/crates/ripgrep_all)\n\n## Examples\n\nSay you have a large folder of papers or lecture slides, and you can't remember which one of them mentioned `LSTM`s. With rga, you can just run this:\n\n```\nrga \"LSTM|GRU\" collection/\n[results]\n```\n\nand it will recursively find a regex in pdfs and pptx slides, including if some of them are zipped up.\n\nYou can do mostly the same thing with [`pdfgrep -r`][pdfgrep], but it will be much slower and you will miss content in other file types.\n\n```barchart\ntitle: Searching in 20 pdfs with 100 slides each\nsubtitle: lower is better\ndata:\n   - pdfgrep: 123s\n   - rga (first run): 10.3s\n   - rga (subsequent runs): 0.1s\n```\n\nOn the first run rga is mostly faster because of multithreading, but on subsequent runs (with the same files but any regex query) rga will cache the text extraction because pdf parsing is slow.\n\n## Setup\n\nrga should compile with stable Rust. To install it, simply run (your OSes equivalent of)\n\n```bash\napt install build-essential pandoc poppler-utils ffmpeg\ncargo install ripgrep_all\n\nrga --help # works! :)\n```\n\nYou don't necessarily need to install any dependencies, but then you will see an error when trying to read from the corresponding file type (e.g. poppler-utils for pdf).\n\n## Technical details\n\n`rga` simply runs ripgrep (`rg`) with some options set, especially `--pre=rga-preproc` and `--pre-glob`.\n\n`rga-preproc [fname]` will match an \"adapter\" to the given file based on either it's filename or it's mime type (if `--accurate` is given). You can see all adapters currently included in [src/adapters](src/adapters).\n\nSome rga adapters run external binaries to do the actual work (such as pandoc or ffmpeg), usually by writing to stdin and reading from stdout. Others use a rust library or bindings to achieve the same effect (like sqlite or zip).\n\nTo read archives, the `zip` and `tar` libraries are used, which work fully in a streaming fashion - this means that the RAM usage is low and no data is ever actually extracted to disk!\n\nMost adapters read the files from a [Read](https://doc.rust-lang.org/std/io/trait.Read.html), so they work completely on streamed data (that can come from anywhere including within nested archives).\n\nDuring the extraction, rga-preproc will compress the data with ZSTD to a memory cache while simultaneously writing it uncompressed to stdout. After completion, if the memory cache is smaller than 2MByte, it is written to a [rkv](https://docs.rs/rkv/0.9.6/rkv/) cache\n\n## Development\n\nTo enable debug logging:\n\n```bash\nexport RUST_LOG=debug\nexport RUST_BACKTRACE=1\n```\n\nAlso rember to disable caching with `--rga-no-cache` or clear the cache in `~/.cache/rga` to debug the adapters.\n\n## Future Work\n\n-   I wanted to add a photograph adapter (based on object classification / detection) for fun, so you can grep for \"mountain\" and it will show pictures of mountains, like in Google Photos. It worked with [YOLO](https://pjreddie.com/darknet/yolo/), but something more useful and state-of-the art [like this](https://github.com/aimagelab/show-control-and-tell) proved very hard to integrate.\n-   7z adapter (couldn't find a nice to use Rust library with streaming)\n-   allow per-adapter configuration options (probably via env (RGA_ADAPTER_CONF=json))\n-   maybe use a different disk kv-store as a cache instead of rkv, because I had some [weird problems](src/preproc_cache.rs#30) with that. SQLite is great. All other Rust alternatives I could find don't allow writing from multiple processes.\n-   there's some more (mostly technical) todos in the code I don't know how to fix\n\n## Similar tools\n\n-   [pdfgrep][pdfgrep]\n-   [this gist](https://gist.github.com/phiresky/5025490526ba70663ab3b8af6c40a8db) has my proof of concept version of a caching extractor to use ripgrep as a replacement for pdfgrep.\n-   [this gist](https://gist.github.com/ColonolBuendia/314826e37ec35c616d70506c38dc65aa) is a more extensive preprocessing script by [@ColonolBuendia](https://github.com/ColonolBuendia)\n\n[pdfgrep]: https://pdfgrep.org/\n[ripgrep]: https://github.com/BurntSushi/ripgrep",bodyHtml:'<p>rga is a line-oriented search tool that allows you to look for a regex in a multitude of file types. It is a wrapper around the awesome <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> that enables it to search in pdf, docx, pptx, movie subtitles (mkv, mp4), sqlite, etc.</p>\n<p><a href="https://travis-ci.org/phiresky/ripgrep_all"><img src="https://api.travis-ci.org/phiresky/ripgrep_all.svg" alt="Linux build status"></a>\n<a href="https://crates.io/crates/ripgrep_all"><img src="https://img.shields.io/crates/v/ripgrep_all.svg" alt="Crates.io"></a></p>\n<h2>Examples</h2>\n<p>Say you have a large folder of papers or lecture slides, and you can\'t remember which one of them mentioned <code>LSTM</code>s. With rga, you can just run this:</p>\n<pre><code>rga &quot;LSTM|GRU&quot; collection/\n[results]\n</code></pre>\n<p>and it will recursively find a regex in pdfs and pptx slides, including if some of them are zipped up.</p>\n<p>You can do mostly the same thing with <a href="https://pdfgrep.org/"><code>pdfgrep -r</code></a>, but it will be much slower and you will miss content in other file types.</p>\n<pre><code class="hljs">title: Searching in 20 pdfs with 100 slides each\nsubtitle: lower is better\ndata:\n   - pdfgrep: 123s\n   - rga (first run): 10.3s\n   - rga (subsequent runs): 0.1s</code></pre><p>On the first run rga is mostly faster because of multithreading, but on subsequent runs (with the same files but any regex query) rga will cache the text extraction because pdf parsing is slow.</p>\n<h2>Setup</h2>\n<p>rga should compile with stable Rust. To install it, simply run (your OSes equivalent of)</p>\n<pre><code class="hljs">apt install build-essential pandoc poppler-utils ffmpeg\ncargo install ripgrep_all\n\nrga --<span class="hljs-built_in">help</span> <span class="hljs-comment"># works! :)</span></code></pre><p>You don\'t necessarily need to install any dependencies, but then you will see an error when trying to read from the corresponding file type (e.g. poppler-utils for pdf).</p>\n<h2>Technical details</h2>\n<p><code>rga</code> simply runs ripgrep (<code>rg</code>) with some options set, especially <code>--pre=rga-preproc</code> and <code>--pre-glob</code>.</p>\n<p><code>rga-preproc [fname]</code> will match an &quot;adapter&quot; to the given file based on either it\'s filename or it\'s mime type (if <code>--accurate</code> is given). You can see all adapters currently included in <a href="src/adapters">src/adapters</a>.</p>\n<p>Some rga adapters run external binaries to do the actual work (such as pandoc or ffmpeg), usually by writing to stdin and reading from stdout. Others use a rust library or bindings to achieve the same effect (like sqlite or zip).</p>\n<p>To read archives, the <code>zip</code> and <code>tar</code> libraries are used, which work fully in a streaming fashion - this means that the RAM usage is low and no data is ever actually extracted to disk!</p>\n<p>Most adapters read the files from a <a href="https://doc.rust-lang.org/std/io/trait.Read.html">Read</a>, so they work completely on streamed data (that can come from anywhere including within nested archives).</p>\n<p>During the extraction, rga-preproc will compress the data with ZSTD to a memory cache while simultaneously writing it uncompressed to stdout. After completion, if the memory cache is smaller than 2MByte, it is written to a <a href="https://docs.rs/rkv/0.9.6/rkv/">rkv</a> cache</p>\n<h2>Development</h2>\n<p>To enable debug logging:</p>\n<pre><code class="hljs"><span class="hljs-built_in">export</span> RUST_LOG=debug\n<span class="hljs-built_in">export</span> RUST_BACKTRACE=1</code></pre><p>Also rember to disable caching with <code>--rga-no-cache</code> or clear the cache in <code>~/.cache/rga</code> to debug the adapters.</p>\n<h2>Future Work</h2>\n<ul>\n<li>I wanted to add a photograph adapter (based on object classification / detection) for fun, so you can grep for &quot;mountain&quot; and it will show pictures of mountains, like in Google Photos. It worked with <a href="https://pjreddie.com/darknet/yolo/">YOLO</a>, but something more useful and state-of-the art <a href="https://github.com/aimagelab/show-control-and-tell">like this</a> proved very hard to integrate.</li>\n<li>7z adapter (couldn\'t find a nice to use Rust library with streaming)</li>\n<li>allow per-adapter configuration options (probably via env (RGA_ADAPTER_CONF=json))</li>\n<li>maybe use a different disk kv-store as a cache instead of rkv, because I had some <a href="src/preproc_cache.rs#30">weird problems</a> with that. SQLite is great. All other Rust alternatives I could find don\'t allow writing from multiple processes.</li>\n<li>there\'s some more (mostly technical) todos in the code I don\'t know how to fix</li>\n</ul>\n<h2>Similar tools</h2>\n<ul>\n<li><a href="https://pdfgrep.org/">pdfgrep</a></li>\n<li><a href="https://gist.github.com/phiresky/5025490526ba70663ab3b8af6c40a8db">this gist</a> has my proof of concept version of a caching extractor to use ripgrep as a replacement for pdfgrep.</li>\n<li><a href="https://gist.github.com/ColonolBuendia/314826e37ec35c616d70506c38dc65aa">this gist</a> is a more extensive preprocessing script by <a href="https://github.com/ColonolBuendia">@ColonolBuendia</a></li>\n</ul>\n',preview:"rga is a line-oriented search tool that allows you to look for a regex in a multitude of file types. It is a",dir:"content",base:"rga.json",ext:".json",sourceBase:"rga.md",sourceExt:".md"}},wzhO:function(e){e.exports={title:"\\[\\[draft]] rga - ripgrep, but also search in PDFs, E-Books, Office documents, zip, tar.gz, etc",date:"2019-06-13T00:00:00.000Z",bodyContent:"rga is a line-oriented search tool that allows you to look for a regex in a multitude of file types. It is a wrapper around the awesome [ripgrep] that enables it to search in pdf, docx, pptx, movie subtitles (mkv, mp4), sqlite, etc.\n\n[![Linux build status](https://api.travis-ci.org/phiresky/ripgrep_all.svg)](https://travis-ci.org/phiresky/ripgrep_all)\n[![Crates.io](https://img.shields.io/crates/v/ripgrep_all.svg)](https://crates.io/crates/ripgrep_all)\n\n## Examples\n\nSay you have a large folder of papers or lecture slides, and you can't remember which one of them mentioned `LSTM`s. With rga, you can just run this:\n\n```\nrga \"LSTM|GRU\" collection/\n[results]\n```\n\nand it will recursively find a regex in pdfs and pptx slides, including if some of them are zipped up.\n\nYou can do mostly the same thing with [`pdfgrep -r`][pdfgrep], but it will be much slower and you will miss content in other file types.\n\n```barchart\ntitle: Searching in 20 pdfs with 100 slides each\nsubtitle: lower is better\ndata:\n   - pdfgrep: 123s\n   - rga (first run): 10.3s\n   - rga (subsequent runs): 0.1s\n```\n\nOn the first run rga is mostly faster because of multithreading, but on subsequent runs (with the same files but any regex query) rga will cache the text extraction because pdf parsing is slow.\n\n## Setup\n\nrga should compile with stable Rust. To install it, simply run (your OSes equivalent of)\n\n```bash\napt install build-essential pandoc poppler-utils ffmpeg\ncargo install ripgrep_all\n\nrga --help # works! :)\n```\n\nYou don't necessarily need to install any dependencies, but then you will see an error when trying to read from the corresponding file type (e.g. poppler-utils for pdf).\n\n## Technical details\n\n`rga` simply runs ripgrep (`rg`) with some options set, especially `--pre=rga-preproc` and `--pre-glob`.\n\n`rga-preproc [fname]` will match an \"adapter\" to the given file based on either it's filename or it's mime type (if `--accurate` is given). You can see all adapters currently included in [src/adapters](src/adapters).\n\nSome rga adapters run external binaries to do the actual work (such as pandoc or ffmpeg), usually by writing to stdin and reading from stdout. Others use a rust library or bindings to achieve the same effect (like sqlite or zip).\n\nTo read archives, the `zip` and `tar` libraries are used, which work fully in a streaming fashion - this means that the RAM usage is low and no data is ever actually extracted to disk!\n\nMost adapters read the files from a [Read](https://doc.rust-lang.org/std/io/trait.Read.html), so they work completely on streamed data (that can come from anywhere including within nested archives).\n\nDuring the extraction, rga-preproc will compress the data with ZSTD to a memory cache while simultaneously writing it uncompressed to stdout. After completion, if the memory cache is smaller than 2MByte, it is written to a [rkv](https://docs.rs/rkv/0.9.6/rkv/) cache\n\n## Development\n\nTo enable debug logging:\n\n```bash\nexport RUST_LOG=debug\nexport RUST_BACKTRACE=1\n```\n\nAlso rember to disable caching with `--rga-no-cache` or clear the cache in `~/.cache/rga` to debug the adapters.\n\n## Future Work\n\n-   I wanted to add a photograph adapter (based on object classification / detection) for fun, so you can grep for \"mountain\" and it will show pictures of mountains, like in Google Photos. It worked with [YOLO](https://pjreddie.com/darknet/yolo/), but something more useful and state-of-the art [like this](https://github.com/aimagelab/show-control-and-tell) proved very hard to integrate.\n-   7z adapter (couldn't find a nice to use Rust library with streaming)\n-   allow per-adapter configuration options (probably via env (RGA_ADAPTER_CONF=json))\n-   maybe use a different disk kv-store as a cache instead of rkv, because I had some [weird problems](src/preproc_cache.rs#30) with that. SQLite is great. All other Rust alternatives I could find don't allow writing from multiple processes.\n-   there's some more (mostly technical) todos in the code I don't know how to fix\n\n## Similar tools\n\n-   [pdfgrep][pdfgrep]\n-   [this gist](https://gist.github.com/phiresky/5025490526ba70663ab3b8af6c40a8db) has my proof of concept version of a caching extractor to use ripgrep as a replacement for pdfgrep.\n-   [this gist](https://gist.github.com/ColonolBuendia/314826e37ec35c616d70506c38dc65aa) is a more extensive preprocessing script by [@ColonolBuendia](https://github.com/ColonolBuendia)\n\n[pdfgrep]: https://pdfgrep.org/\n[ripgrep]: https://github.com/BurntSushi/ripgrep",bodyHtml:'<p>rga is a line-oriented search tool that allows you to look for a regex in a multitude of file types. It is a wrapper around the awesome <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> that enables it to search in pdf, docx, pptx, movie subtitles (mkv, mp4), sqlite, etc.</p>\n<p><a href="https://travis-ci.org/phiresky/ripgrep_all"><img src="https://api.travis-ci.org/phiresky/ripgrep_all.svg" alt="Linux build status"></a>\n<a href="https://crates.io/crates/ripgrep_all"><img src="https://img.shields.io/crates/v/ripgrep_all.svg" alt="Crates.io"></a></p>\n<h2>Examples</h2>\n<p>Say you have a large folder of papers or lecture slides, and you can\'t remember which one of them mentioned <code>LSTM</code>s. With rga, you can just run this:</p>\n<pre><code>rga &quot;LSTM|GRU&quot; collection/\n[results]\n</code></pre>\n<p>and it will recursively find a regex in pdfs and pptx slides, including if some of them are zipped up.</p>\n<p>You can do mostly the same thing with <a href="https://pdfgrep.org/"><code>pdfgrep -r</code></a>, but it will be much slower and you will miss content in other file types.</p>\n<pre><code class="hljs">title: Searching in 20 pdfs with 100 slides each\nsubtitle: lower is better\ndata:\n   - pdfgrep: 123s\n   - rga (first run): 10.3s\n   - rga (subsequent runs): 0.1s</code></pre><p>On the first run rga is mostly faster because of multithreading, but on subsequent runs (with the same files but any regex query) rga will cache the text extraction because pdf parsing is slow.</p>\n<h2>Setup</h2>\n<p>rga should compile with stable Rust. To install it, simply run (your OSes equivalent of)</p>\n<pre><code class="hljs">apt install build-essential pandoc poppler-utils ffmpeg\ncargo install ripgrep_all\n\nrga --<span class="hljs-built_in">help</span> <span class="hljs-comment"># works! :)</span></code></pre><p>You don\'t necessarily need to install any dependencies, but then you will see an error when trying to read from the corresponding file type (e.g. poppler-utils for pdf).</p>\n<h2>Technical details</h2>\n<p><code>rga</code> simply runs ripgrep (<code>rg</code>) with some options set, especially <code>--pre=rga-preproc</code> and <code>--pre-glob</code>.</p>\n<p><code>rga-preproc [fname]</code> will match an &quot;adapter&quot; to the given file based on either it\'s filename or it\'s mime type (if <code>--accurate</code> is given). You can see all adapters currently included in <a href="src/adapters">src/adapters</a>.</p>\n<p>Some rga adapters run external binaries to do the actual work (such as pandoc or ffmpeg), usually by writing to stdin and reading from stdout. Others use a rust library or bindings to achieve the same effect (like sqlite or zip).</p>\n<p>To read archives, the <code>zip</code> and <code>tar</code> libraries are used, which work fully in a streaming fashion - this means that the RAM usage is low and no data is ever actually extracted to disk!</p>\n<p>Most adapters read the files from a <a href="https://doc.rust-lang.org/std/io/trait.Read.html">Read</a>, so they work completely on streamed data (that can come from anywhere including within nested archives).</p>\n<p>During the extraction, rga-preproc will compress the data with ZSTD to a memory cache while simultaneously writing it uncompressed to stdout. After completion, if the memory cache is smaller than 2MByte, it is written to a <a href="https://docs.rs/rkv/0.9.6/rkv/">rkv</a> cache</p>\n<h2>Development</h2>\n<p>To enable debug logging:</p>\n<pre><code class="hljs"><span class="hljs-built_in">export</span> RUST_LOG=debug\n<span class="hljs-built_in">export</span> RUST_BACKTRACE=1</code></pre><p>Also rember to disable caching with <code>--rga-no-cache</code> or clear the cache in <code>~/.cache/rga</code> to debug the adapters.</p>\n<h2>Future Work</h2>\n<ul>\n<li>I wanted to add a photograph adapter (based on object classification / detection) for fun, so you can grep for &quot;mountain&quot; and it will show pictures of mountains, like in Google Photos. It worked with <a href="https://pjreddie.com/darknet/yolo/">YOLO</a>, but something more useful and state-of-the art <a href="https://github.com/aimagelab/show-control-and-tell">like this</a> proved very hard to integrate.</li>\n<li>7z adapter (couldn\'t find a nice to use Rust library with streaming)</li>\n<li>allow per-adapter configuration options (probably via env (RGA_ADAPTER_CONF=json))</li>\n<li>maybe use a different disk kv-store as a cache instead of rkv, because I had some <a href="src/preproc_cache.rs#30">weird problems</a> with that. SQLite is great. All other Rust alternatives I could find don\'t allow writing from multiple processes.</li>\n<li>there\'s some more (mostly technical) todos in the code I don\'t know how to fix</li>\n</ul>\n<h2>Similar tools</h2>\n<ul>\n<li><a href="https://pdfgrep.org/">pdfgrep</a></li>\n<li><a href="https://gist.github.com/phiresky/5025490526ba70663ab3b8af6c40a8db">this gist</a> has my proof of concept version of a caching extractor to use ripgrep as a replacement for pdfgrep.</li>\n<li><a href="https://gist.github.com/ColonolBuendia/314826e37ec35c616d70506c38dc65aa">this gist</a> is a more extensive preprocessing script by <a href="https://github.com/ColonolBuendia">@ColonolBuendia</a></li>\n</ul>\n',preview:"rga is a line-oriented search tool that allows you to look for a regex in a multitude of file types. It is a",dir:"content/posts/2019",base:"rga.json",ext:".json",sourceBase:"rga.md",sourceExt:".md"}},zeTH:function(e){e.exports={title:"Custom post",date:"2017-06-01T00:00:00.000Z",page:"post",paths:["/custom-post","/custom-post-alias","/subpath/custom-post-alias"],bodyContent:"An [alias](/subpath/custom-post-alias)\n\nAnd another [alias](/custom-post-alias)",bodyHtml:'<p>An <a href="/subpath/custom-post-alias">alias</a></p>\n<p>And another <a href="/custom-post-alias">alias</a></p>\n',preview:"An alias\n\nAnd another alias",dir:"content",base:"custom-post.json",ext:".json",sourceBase:"custom-post.md",sourceExt:".md"}}},[["SXBd","5d41","9da1"]]]);